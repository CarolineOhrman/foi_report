---
title: SHotgun Metagenomics sequence report
subtitle: Sample summary, statistics and composition
author: FOI-bioinformatics
date: 2025-06-17
categories:
  - kraken2
  - fastqc
slug: patchwork
page-layout: full
image: ../assets/images/nanopore.jpg
---
# General statistics

## Read count

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
library(grid)

# Function to parse FastQC data
parse_fastqc <- function(file_path, read_type) {
  # Read the file
  lines <- readLines(file_path)
  
  # Find Basic Statistics section
  start_idx <- which(grepl(">>Basic Statistics", lines))
  end_idx <- which(grepl(">>END_MODULE", lines))[1]
  
  # Extract the status (pass/fail)
  status_line <- lines[start_idx]
  status <- trimws(strsplit(status_line, "\t")[[1]][2])
  
  # Extract the data lines (skip header line with #Measure Value)
  data_lines <- lines[(start_idx + 2):(end_idx - 1)]
  
  # Parse each line
  parsed_data <- data.frame(
    Read = read_type,
    Measure = character(0),
    Value = character(0),
    stringsAsFactors = FALSE
  )
  
  for (line in data_lines) {
    if (grepl("^#", line)) next  # Skip comment lines
    parts <- strsplit(line, "\t")[[1]]
    if (length(parts) >= 2) {
      parsed_data <- rbind(parsed_data, data.frame(
        Read = read_type,
        Measure = parts[1],
        Value = parts[2],
        stringsAsFactors = FALSE
      ))
    }
  }
  
  # Add status as first row
  status_row <- data.frame(
    Read = read_type,
    Measure = "QC Status",
    Value = status,
    stringsAsFactors = FALSE
  )
  
  parsed_data <- rbind(status_row, parsed_data)
  return(parsed_data)
}

# Parse both files
# Note: I corrected the typo from "fatqc_data.txt" to "fastqc_data.txt"
r1_data <- parse_fastqc("../results/fastqc/MI173C_fastp_R1_fastqc/fastqc_data.txt", "R1")
r2_data <- parse_fastqc("../results/fastqc/MI173C_fastp_R2_fastqc/fastqc_data.txt", "R2")

# Combine data
combined_data <- rbind(r1_data, r2_data)

# Reshape data for table format
table_data <- combined_data %>%
  tidyr::pivot_wider(names_from = Read, values_from = Value) %>%
  select(Measure, R1, R2)

# Create a nice table using ggplot2
create_fastqc_table <- function(data, sample_name) {
  # Prepare data for plotting
  n_rows <- nrow(data)
  
  # Create a base plot
  p <- ggplot() + 
    theme_void() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
      plot.margin = margin(20, 20, 20, 20)
    ) +
    labs(title = paste("FastQC Summary -", sample_name)) +
    xlim(0, 10) + 
    ylim(0, n_rows + 2)
  
  # Add header
  p <- p + 
    annotate("rect", xmin = 0.5, xmax = 9.5, ymin = n_rows + 0.5, ymax = n_rows + 1.5, 
             fill = "#2E86AB", color = "white", size = 0.5) +
    annotate("text", x = 2.5, y = n_rows + 1, label = "Measure", 
             color = "white", fontface = "bold", size = 4) +
    annotate("text", x = 5.5, y = n_rows + 1, label = "R1 (Forward)", 
             color = "white", fontface = "bold", size = 4) +
    annotate("text", x = 8, y = n_rows + 1, label = "R2 (Reverse)", 
             color = "white", fontface = "bold", size = 4)
  
  # Add data rows
  for (i in 1:n_rows) {
    y_pos <- n_rows - i + 1
    
    # Alternate row colors
    fill_color <- if (i %% 2 == 0) "#F8F9FA" else "white"
    
    # Determine text color based on QC status
    text_color <- "black"
    if (data$Measure[i] == "QC Status") {
      if (data$R1[i] == "pass" && data$R2[i] == "pass") {
        text_color <- "#28A745"  # Green for pass
      } else {
        text_color <- "#DC3545"  # Red for fail/warn
      }
    }
    
    p <- p + 
      annotate("rect", xmin = 0.5, xmax = 9.5, ymin = y_pos - 0.4, ymax = y_pos + 0.4, 
               fill = fill_color, color = "#DEE2E6", size = 0.3) +
      annotate("text", x = 2.5, y = y_pos, label = data$Measure[i], 
               hjust = 0.5, size = 3.5, fontface = ifelse(data$Measure[i] == "QC Status", "bold", "plain")) +
      annotate("text", x = 5.5, y = y_pos, label = data$R1[i], 
               hjust = 0.5, size = 3.5, color = text_color,
               fontface = ifelse(data$Measure[i] == "QC Status", "bold", "plain")) +
      annotate("text", x = 8, y = y_pos, label = data$R2[i], 
               hjust = 0.5, size = 3.5, color = text_color,
               fontface = ifelse(data$Measure[i] == "QC Status", "bold", "plain"))
  }
  
  return(p)
}

# Create the table
fastqc_table <- create_fastqc_table(table_data, "MI173C")

# Display the table
print(fastqc_table)

# Save the table
ggsave("MI173C_fastqc_summary_table.png", fastqc_table, 
       width = 12, height = 8, dpi = 300, bg = "white")

# Alternative: Create a more advanced table using gt package (if available)
if (require(gt, quietly = TRUE)) {
  advanced_table <- table_data %>%
    gt() %>%
    tab_header(
      title = "FastQC Quality Control Summary",
      subtitle = "Sample: MI173C"
    ) %>%
    tab_style(
      style = list(
        cell_text(weight = "bold"),
        cell_fill(color = "#2E86AB"),
        cell_text(color = "white")
      ),
      locations = cells_column_labels()
    ) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_body(columns = Measure, rows = Measure == "QC Status")
    ) %>%
    tab_style(
      style = cell_text(color = "#28A745", weight = "bold"),
      locations = cells_body(columns = c(R1, R2), rows = Measure == "QC Status" & (R1 == "pass" | R2 == "pass"))
    ) %>%
    tab_style(
      style = cell_text(color = "#DC3545", weight = "bold"),
      locations = cells_body(columns = c(R1, R2), rows = Measure == "QC Status" & (R1 != "pass" | R2 != "pass"))
    ) %>%
    opt_row_striping() %>%
    cols_align(align = "center", columns = c(R1, R2)) %>%
    cols_width(
      Measure ~ px(200),
      R1 ~ px(150),
      R2 ~ px(150)
    )
  
  print(advanced_table)
  
  # Save gt table
  gtsave(advanced_table, "MI173C_fastqc_summary_gt.png")
}

# Print summary
cat("\nFastQC Summary for sample MI173C:\n")
cat("================================\n")
print(table_data)
```
## Other


#  Classification

## kraken2


Using plotly to be able to interactively choose taxonomic level

```{r}
#| echo: false
#| message: false
#| warning: false

library(tidyverse)
library(plotly)

# Read the data and extract sample names
lines <- read_lines(
  "../results/classification/kraken2/illumina_kraken2_fastp_0.1.report"
)

# Extract sample names from the header lines
sample_lines <- lines[str_starts(lines, "#S")]
sample_info <- map_dfr(sample_lines, function(line) {
  parts <- str_split(line, "\t")[[1]]
  sample_id <- str_remove(parts[1], "#")
  file_path <- parts[2]
  # Extract sample name (part before _kraken2_rawreads)
  sample_name <- str_extract(
    basename(file_path),
    "([^/]+)(?=_kraken2_rawreads)"
  )
  tibble(sample_id = sample_id, sample_name = sample_name)
})

# Find the header line (starts with #perc)
header_idx <- which(str_starts(lines, "#perc"))

# Remove the # from the header line
lines[header_idx] <- str_remove(lines[header_idx], "^#")

# Keep only header and data lines (skip metadata)
data_lines <- lines[header_idx:length(lines)]

# Parse the data
data <- read_tsv(
  paste(data_lines, collapse = "\n"),
  col_types = cols(
    perc = "d",
    tot_all = "d",
    tot_lvl = "d",
    .default = "c"
  )
) %>%
  # Filter for meaningful taxonomic levels and abundance > 0.01%
  filter(
    lvl_type %in% c("P", "C", "O", "F", "G", "S"),
    !str_detect(name, "unclassified|root|cellular organisms")
  ) %>%
  # Clean up taxonomic names
  mutate(
    name = str_trim(name),
    lvl_type_full = case_when(
      lvl_type == "P" ~ "Phylum",
      lvl_type == "C" ~ "Class",
      lvl_type == "O" ~ "Order",
      lvl_type == "F" ~ "Family",
      lvl_type == "G" ~ "Genus",
      lvl_type == "S" ~ "Species",
      TRUE ~ lvl_type
    )
  )

# Function to create plot for a specific sample
create_sample_plot <- function(sample_id) {
  # Get sample name
  sample_name <- sample_info$sample_name[sample_info$sample_id == sample_id]

  # Prepare data for this sample
  sample_data <- data %>%
    select(
      name,
      lvl_type,
      lvl_type_full,
      taxid,
      all_of(paste0(sample_id, "_all"))
    ) %>%
    rename(abundance = paste0(sample_id, "_all")) %>%
    mutate(
      abundance = as.numeric(abundance),
      perc_sample = (abundance / sum(abundance, na.rm = TRUE)) * 100
    ) %>%
    filter(
      abundance > 0,
      perc_sample > 0.01 # Filter for >0.01% abundance in this sample
    ) %>%
    # Get top 15 for each taxonomic level
    group_by(lvl_type) %>%
    slice_max(perc_sample, n = 15) %>%
    ungroup()

  # Define reverse order for taxonomic levels (Species first)
  level_order <- c("S", "G", "F", "O", "C", "P")
  available_levels <- intersect(level_order, unique(sample_data$lvl_type))

  # Color palette - assign colors based on reverse order
  colors <- c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b")
  lvl_colors <- setNames(
    colors[1:length(available_levels)],
    available_levels
  )

  # Create the interactive plotly chart
  p <- plot_ly()

  # Add traces for each taxonomic level in reverse order
  for (level in available_levels) {
    plot_data <- sample_data %>%
      filter(lvl_type == level) %>%
      arrange(perc_sample) %>% # Arrange in ascending order for horizontal bars
      mutate(name = factor(name, levels = name))

    if (nrow(plot_data) > 0) {
      p <- p %>%
        add_trace(
          data = plot_data,
          x = ~perc_sample,
          y = ~name,
          type = "bar",
          orientation = "h",
          name = paste0(level, " (", first(plot_data$lvl_type_full), ")"),
          marker = list(color = lvl_colors[[level]]),
          visible = if (level == "S") TRUE else FALSE, # Show Species by default
          hovertemplate = paste(
            "<b>%{y}</b><br>",
            "Abundance: %{x:.2f}%<br>",
            "Read count: ",
            plot_data$abundance,
            "<br>",
            "Level: ",
            first(plot_data$lvl_type_full),
            "<extra></extra>"
          )
        )
    }
  }

  # Add dropdown menu in reverse order (Species first) - positioned in lower right, dropping up
  updatemenus <- list(
    list(
      active = 0,
      type = "dropdown",
      direction = "up", # Make the dropdown open upward
      buttons = map(available_levels, function(level) {
        level_full <- sample_data %>%
          filter(lvl_type == level) %>%
          pull(lvl_type_full) %>%
          first()

        visible_vector <- map_lgl(
          available_levels,
          ~ .x == level
        )

        list(
          label = paste0(level, " (", level_full, ")"),
          method = "update",
          args = list(list(visible = visible_vector))
        )
      }),
      x = 1, # Right edge
      y = 0.15 # Lower position
    )
  )

  # Final layout
  p <- p %>%
    layout(
      title = list(
        text = paste0("Sample: <b>", sample_name, "</b>"),
        x = 0.5
      ),
      xaxis = list(title = "Relative Abundance (%)"),
      yaxis = list(title = ""),
      updatemenus = updatemenus,
      margin = list(l = 200, r = 150),
      showlegend = FALSE
    ) %>%
    config(
      displayModeBar = FALSE, # Remove the toolbar completely
      scrollZoom = FALSE, # Disable scroll zoom
      doubleClick = FALSE, # Disable double-click zoom
      displaylogo = FALSE # Remove plotly logo
    )
  return(p)
}

# Create function to generate plots on demand
create_all_plots <- function() {
  plots <- list()
  for (i in 1:nrow(sample_info)) {
    plots[[i]] <- create_sample_plot(sample_info$sample_id[i])
  }
  return(plots)
}

# Generate all plots
sample_plots <- create_all_plots()

# Using htmltools::tagList()

library(htmltools)
tagList(
  map(
    sample_plots,
    ~ {
      tagList(
        .x,
        br(),
        br() # Add two line breaks between each plot
      )
    }
  )
)

```

