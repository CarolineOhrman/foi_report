---
title: Shotgun Metagenomics sequence report
subtitle: Sample summary, statistics and composition
author: FOI-bioinformatics
date: 2025-06-17
categories:
  - kraken2
  - fastqc
slug: patchwork
page-layout: full
image: ../assets/images/nanopore.jpg
---
# General statistics

```{r}
#| echo: false
#| message: false
#| warning: false

library(ggplot2)
library(dplyr)
library(tidyr)

# Simple FastQC parser
parse_fastqc <- function(file_path, read_type) {
  lines <- readLines(file_path)
  start_line <- which(grepl(">>Basic Statistics", lines))[1]
  end_line <- which(grepl(">>END_MODULE", lines))
  end_line <- end_line[end_line > start_line][1]

  status <- strsplit(lines[start_line], "\t")[[1]][2]
  data_section <- lines[(start_line + 2):(end_line - 1)]

  measures <- c("QC Status")
  values <- c(status)

  for (line in data_section) {
    if (!grepl("^#", line) && nchar(trimws(line)) > 0) {
      parts <- strsplit(line, "\t")[[1]]
      if (length(parts) >= 2) {
        measures <- c(measures, parts[1])
        values <- c(values, parts[2])
      }
    }
  }

  data.frame(
    Read = read_type,
    Measure = measures,
    Value = values,
    stringsAsFactors = FALSE
  )
}

# Read data and create table
r1_data <- parse_fastqc(
  "../results/fastqc/MI173C_fastp_R1_fastqc/fastqc_data.txt",
  "R1"
)
r2_data <- parse_fastqc(
  "../results/fastqc/MI173C_fastp_R2_fastqc/fastqc_data.txt",
  "R2"
)

table_data <- rbind(r1_data, r2_data) %>%
  pivot_wider(names_from = Read, values_from = Value)

# Create full-width table
n_rows <- nrow(table_data)

p <- ggplot() +
  theme_void() +
  labs(title = "FastQC Summary - Sample MI173C") +
  theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
  xlim(0, 100) +
  ylim(0, n_rows + 2)

# Header
p <- p +
  annotate(
    "rect",
    xmin = 0,
    xmax = 100,
    ymin = n_rows + 0.5,
    ymax = n_rows + 1.5,
    fill = "#2E86AB",
    color = "white"
  ) +
  annotate(
    "text",
    x = 25,
    y = n_rows + 1,
    label = "Measure",
    color = "white",
    fontface = "bold",
    size = 4
  ) +
  annotate(
    "text",
    x = 60,
    y = n_rows + 1,
    label = "R1 (Forward)",
    color = "white",
    fontface = "bold",
    size = 4
  ) +
  annotate(
    "text",
    x = 85,
    y = n_rows + 1,
    label = "R2 (Reverse)",
    color = "white",
    fontface = "bold",
    size = 4
  )

# Data rows
for (i in 1:n_rows) {
  y_pos <- n_rows - i + 1
  fill_color <- if (i %% 2 == 0) "#F8F9FA" else "white"

  text_color <- "black"
  if (table_data$Measure[i] == "QC Status") {
    text_color <- if (
      table_data$R1[i] == "pass" && table_data$R2[i] == "pass"
    ) {
      "#28A745"
    } else {
      "#DC3545"
    }
  }

  p <- p +
    annotate(
      "rect",
      xmin = 0,
      xmax = 100,
      ymin = y_pos - 0.4,
      ymax = y_pos + 0.4,
      fill = fill_color,
      color = "#DEE2E6"
    ) +
    annotate(
      "text",
      x = 25,
      y = y_pos,
      label = table_data$Measure[i],
      hjust = 0.5,
      size = 3.5
    ) +
    annotate(
      "text",
      x = 60,
      y = y_pos,
      label = table_data$R1[i],
      hjust = 0.5,
      size = 3.5,
      color = text_color
    ) +
    annotate(
      "text",
      x = 85,
      y = y_pos,
      label = table_data$R2[i],
      hjust = 0.5,
      size = 3.5,
      color = text_color
    )
}

print(p)
```

#  Classification with kraken2

Using plotly to be able to interactively choose taxonomic level

```{r}
#| echo: false
#| message: false
#| warning: false

library(tidyverse)
library(plotly)

# Read the data and extract sample names
lines <- read_lines(
  "../results/classification/kraken2/illumina_kraken2_fastp_0.1.report"
)

# Extract sample names from the header lines
sample_lines <- lines[str_starts(lines, "#S")]
sample_info <- map_dfr(sample_lines, function(line) {
  parts <- str_split(line, "\t")[[1]]
  sample_id <- str_remove(parts[1], "#")
  file_path <- parts[2]
  # Extract sample name (part before _kraken2_rawreads)
  sample_name <- str_extract(
    basename(file_path),
    "([^/]+)(?=_kraken2_rawreads)"
  )
  tibble(sample_id = sample_id, sample_name = sample_name)
})

# Find the header line (starts with #perc)
header_idx <- which(str_starts(lines, "#perc"))

# Remove the # from the header line
lines[header_idx] <- str_remove(lines[header_idx], "^#")

# Keep only header and data lines (skip metadata)
data_lines <- lines[header_idx:length(lines)]

# Parse the data
data <- read_tsv(
  paste(data_lines, collapse = "\n"),
  col_types = cols(
    perc = "d",
    tot_all = "d",
    tot_lvl = "d",
    .default = "c"
  )
) %>%
  # Filter for meaningful taxonomic levels and abundance > 0.01%
  filter(
    lvl_type %in% c("P", "C", "O", "F", "G", "S"),
    !str_detect(name, "unclassified|root|cellular organisms")
  ) %>%
  # Clean up taxonomic names
  mutate(
    name = str_trim(name),
    lvl_type_full = case_when(
      lvl_type == "P" ~ "Phylum",
      lvl_type == "C" ~ "Class",
      lvl_type == "O" ~ "Order",
      lvl_type == "F" ~ "Family",
      lvl_type == "G" ~ "Genus",
      lvl_type == "S" ~ "Species",
      TRUE ~ lvl_type
    )
  )

# Function to create plot for a specific sample
create_sample_plot <- function(sample_id) {
  # Get sample name
  sample_name <- sample_info$sample_name[sample_info$sample_id == sample_id]

  # Prepare data for this sample
  sample_data <- data %>%
    select(
      name,
      lvl_type,
      lvl_type_full,
      taxid,
      all_of(paste0(sample_id, "_all"))
    ) %>%
    rename(abundance = paste0(sample_id, "_all")) %>%
    mutate(
      abundance = as.numeric(abundance),
      perc_sample = (abundance / sum(abundance, na.rm = TRUE)) * 100
    ) %>%
    filter(
      abundance > 0,
      perc_sample > 0.01 # Filter for >0.01% abundance in this sample
    ) %>%
    # Get top 15 for each taxonomic level
    group_by(lvl_type) %>%
    slice_max(perc_sample, n = 15) %>%
    ungroup()

  # Define reverse order for taxonomic levels (Species first)
  level_order <- c("S", "G", "F", "O", "C", "P")
  available_levels <- intersect(level_order, unique(sample_data$lvl_type))

  # Color palette - assign colors based on reverse order
  colors <- c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b")
  lvl_colors <- setNames(
    colors[1:length(available_levels)],
    available_levels
  )

  # Create the interactive plotly chart
  p <- plot_ly()

  # Add traces for each taxonomic level in reverse order
  for (level in available_levels) {
    plot_data <- sample_data %>%
      filter(lvl_type == level) %>%
      arrange(perc_sample) %>% # Arrange in ascending order for horizontal bars
      mutate(name = factor(name, levels = name))

    if (nrow(plot_data) > 0) {
      p <- p %>%
        add_trace(
          data = plot_data,
          x = ~perc_sample,
          y = ~name,
          type = "bar",
          orientation = "h",
          name = paste0(level, " (", first(plot_data$lvl_type_full), ")"),
          marker = list(color = lvl_colors[[level]]),
          visible = if (level == "S") TRUE else FALSE, # Show Species by default
          hovertemplate = paste(
            "<b>%{y}</b><br>",
            "Abundance: %{x:.2f}%<br>",
            "Read count: ",
            plot_data$abundance,
            "<br>",
            "Level: ",
            first(plot_data$lvl_type_full),
            "<extra></extra>"
          )
        )
    }
  }

  # Add dropdown menu in reverse order (Species first) - positioned in lower right, dropping up
  updatemenus <- list(
    list(
      active = 0,
      type = "dropdown",
      direction = "up", # Make the dropdown open upward
      buttons = map(available_levels, function(level) {
        level_full <- sample_data %>%
          filter(lvl_type == level) %>%
          pull(lvl_type_full) %>%
          first()

        visible_vector <- map_lgl(
          available_levels,
          ~ .x == level
        )

        list(
          label = paste0(level, " (", level_full, ")"),
          method = "update",
          args = list(list(visible = visible_vector))
        )
      }),
      x = 1, # Right edge
      y = 0.15 # Lower position
    )
  )

  # Final layout
  p <- p %>%
    layout(
      title = list(
        text = paste0("Sample: <b>", sample_name, "</b>"),
        x = 0.5
      ),
      xaxis = list(title = "Relative Abundance (%)"),
      yaxis = list(title = ""),
      updatemenus = updatemenus,
      margin = list(l = 200, r = 150),
      showlegend = FALSE
    ) %>%
    config(
      displayModeBar = FALSE, # Remove the toolbar completely
      scrollZoom = FALSE, # Disable scroll zoom
      doubleClick = FALSE, # Disable double-click zoom
      displaylogo = FALSE # Remove plotly logo
    )
  return(p)
}

# Create function to generate plots on demand
create_all_plots <- function() {
  plots <- list()
  for (i in 1:nrow(sample_info)) {
    plots[[i]] <- create_sample_plot(sample_info$sample_id[i])
  }
  return(plots)
}

# Generate all plots
sample_plots <- create_all_plots()

# Using htmltools::tagList()

library(htmltools)
tagList(
  map(
    sample_plots,
    ~ {
      tagList(
        .x,
        br(),
        br() # Add two line breaks between each plot
      )
    }
  )
)

```

